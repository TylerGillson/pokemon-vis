<!DOCTYPE html>
<!--suppress CssUnusedSymbol, JSUnresolvedVariable -->
<meta charset="utf-8">

<!-- Load d3 & jQuery -->
<script src="http://d3js.org/d3.v4.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<style>
    @font-face {
        font-family: 'poke_solid';
        src: url('fonts/PokemonSolid.ttf') format('truetype');
    }
    @font-face {
        font-family: 'poke_hollow';
        src: url('fonts/PokemonHollow.ttf') format('truetype');
    }

    .title {
        position: absolute;
        margin-top: 10px;
        margin-left: 20px;
        font-size: 30px;
        font-family: poke_solid, serif;
    }

    #dropdowns {
        position: absolute;
        margin-top: 70px;
        margin-left: 20px;
        font-family: poke_solid, serif;
        color: yellow;
        text-shadow: -2px 0 blue, 0 2px blue, 2px 0 blue, 0 -2px blue;
    }

    .typeText {
        font-family: poke_solid, serif;
    }

    .featured_pokemon.title {
        font-family: poke_solid, serif;
        text-shadow: -4px 0 blue, 0 4px blue, 4px 0 blue, 0 -4px blue;
    }

    select {
        margin-top: 5px;
    }
</style>

<!-- Create a div where the vis will take place -->
<div id="pokemon_vis"></div>
<script>

    // Set the dimensions and margins of the vis
    let margin = {top: 100, right: 100, bottom: 100, left: 100},
        width = 1400 - margin.left - margin.right,
        height = 800 - margin.top - margin.bottom,
        innerRadius = 90;

    // Configure pan & zoom
    let transform = d3.zoomIdentity.translate((width / 2) + 90, (height / 2) + 90); // used to re-center on zoom
    let zoom = d3.zoom();

    // Vis defaults
    let bySubType = false;
    let sortingAttribute = "pokedex_number";
    let svg = null;

    // Scales for stat bars:
    let attackColor, hpColor, defenseColor, spAttackColor, spDefenseColor, speedColor = null;
    let attackBar, hpBar, defenseBar, spAttackBar, spDefenseBar, speedBar = null;
    let featuringPokemon = false;

    // Method for creating/re-creating the vis's svg object
    function add_svg() {
        svg = d3.select("#pokemon_vis")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .call(d3.zoom()
                .on("zoom", () => {
                    svg.attr("transform", d3.event.transform)
                }))
            .call(zoom.transform, transform)
            .append("g")
            .attr("transform", "translate(" + (width / 2 + margin.left) + "," + (height / 2 + margin.top) + ")");
    }

    function drawPokeball() {
        svg.append("g")
            .append("svg:image")
            .attr("xlink:href", "pokeball.png")
            .attr("class", "pokeball")
            .attr("pointer-events", "none")
            .attr("width", 180)
            .attr("height", 180)
            .attr("x", -90)
            .attr("y", -90);
    }

    // Method for drawing the vis
    function show_vis(bySubType, sortingAttribute, svg, drawLabels=true) {
        d3.csv("pokemon_data.csv", function(data) {
            // Scales
            let max = d3.max(data, function(d) { return parseInt(d.attack); }) + 5;
            let min = d3.min(data, function(d) { return parseInt(d.attack); }) - 5;
            attackBar = d3.scaleLinear().domain([min, max]).range([0,70]);
            attackColor = d3.scaleLinear().domain([min, max]).interpolate(d3.interpolateHcl).range([d3.rgb("#f00"), d3.rgb('#008000')]);

            max = d3.max(data, function(d) { return parseInt(d.defense); }) + 5;
            min = d3.min(data, function(d) { return parseInt(d.defense); }) - 5;
            defenseBar = d3.scaleLinear().domain([min, max]).range([0,70]);
            defenseColor = d3.scaleLinear().domain([min, max]).interpolate(d3.interpolateHcl).range([d3.rgb("#f00"), d3.rgb('#008000')]);

            max = d3.max(data, function(d) { return parseInt(d.hp); }) + 5;
            min = d3.min(data, function(d) { return parseInt(d.hp); }) - 5;
            hpBar = d3.scaleLinear().domain([min, max]).range([0,70]);
            hpColor = d3.scaleLinear().domain([min, max]).interpolate(d3.interpolateHcl).range([d3.rgb("#f00"), d3.rgb('#008000')]);

            max = d3.max(data, function(d) { return parseInt(d.sp_attack); }) + 5;
            min = d3.min(data, function(d) { return parseInt(d.sp_attack); }) - 5;
            spAttackBar = d3.scaleLinear().domain([min, max]).range([0,70]);
            spAttackColor = d3.scaleLinear().domain([min, max]).interpolate(d3.interpolateHcl).range([d3.rgb("#f00"), d3.rgb('#008000')]);

            max = d3.max(data, function(d) { return parseInt(d.sp_defense); }) + 5;
            min = d3.min(data, function(d) { return parseInt(d.sp_defense); }) - 5;
            spDefenseBar = d3.scaleLinear().domain([min, max]).range([0,70]);
            spDefenseColor = d3.scaleLinear().domain([min, max]).interpolate(d3.interpolateHcl).range([d3.rgb("#f00"), d3.rgb('#008000')]);

            max = d3.max(data, function(d) { return parseInt(d.speed); }) + 5;
            min = d3.min(data, function(d) { return parseInt(d.speed); }) - 5;
            speedBar = d3.scaleLinear().domain([min, max]).range([0,70]);
            speedColor = d3.scaleLinear().domain([min, max]).interpolate(d3.interpolateHcl).range([d3.rgb("#f00"), d3.rgb('#008000')]);

            let getBarScales = function(i) {
                switch (i) {
                    case 0: return [attackBar, attackColor];
                    case 1: return [defenseBar, defenseColor];
                    case 2: return [hpBar, hpColor];
                    case 3: return [spAttackBar, spAttackColor];
                    case 4: return [spDefenseBar, spDefenseColor];
                    case 5: return [speedBar, speedColor];
                }
            };

            // x-scale for unique primary types
            let x = d3.scaleBand()
                .range([0, 2 * Math.PI])  // x-axis goes from 0 to 2pi = all around the circle
                .domain(data.map(function(d) { return d.type1; }));  // domain of the x-axis = primary pokemon types

            // x-scale for unique type combos
            let x2 = d3.scaleBand()
                .range([0, 2 * Math.PI])
                .domain(data.map(function(d) { return getTypeCombo(d); }));

            let uniquePrimaryTypes = d3.nest()
                .key(function(d) { return d.type1; })
                .entries(data);

            let uniqueTypeCombos = d3.nest()
                .key(function(d) { return getTypeCombo(d); })
                .entries(data);

            // Set radials and x-scale according to vis type
            let radials = (bySubType) ? uniqueTypeCombos : uniquePrimaryTypes;
            let xScale = (bySubType) ? x2 : x;

            // Add central pokeball
            drawPokeball();

            // Determine maximum value for selected attribute for each type
            let typeCounts = {};
            let overallMin = 100;
            let overallMax = 0;
            let typeCountValues = new Array(radials.length);

            for (let i=0; i<radials.length; i++) {
                let pokemon = getSortedPokemonByTypeDescAndAttr(data, radials[i].key, sortingAttribute);
                let count = pokemon.length;
                if (count > overallMax) overallMax = count;
                if (count < overallMin) overallMin = count;
                typeCounts[radials[i].key] = count;
                typeCountValues[i] = count;
            }

            // Set y-axis
            let imgDelta = (bySubType) ? 18 : 38;
            let yMinDelta = overallMin * imgDelta;
            let yMaxDelta = overallMax * imgDelta;
            let y = d3.scaleLinear()
                .domain([0, overallMax])
                .range([innerRadius + yMinDelta, innerRadius + yMaxDelta]);

            // Add the type arcs, computing & storing the midpoint of each arc's bottom path
            let arcBaseMidpoints = new Array(radials.length);
            svg.append("g")
                .selectAll("path")
                .data(radials)
                .enter()
                .append("path")
                .attr("class", "typeArc")
                .attr("id", function(d, i) { return "typeArc_" + i; })  // Unique id for each arc
                .attr("fill", "transparent")
                .attr("d", d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(function(d) { return y(typeCounts[d.key]); })
                    .startAngle(function(d) { return xScale(d.key); })
                    .endAngle(function(d) { return xScale(d.key) + xScale.bandwidth(); })
                    .padAngle(0.05)
                    .padRadius(innerRadius))
                .each(function(d, i) {
                    // Determine midpoint of bottom path of each arc
                    let bottomSection = /L(.*?)$/;
                    let bottom = bottomSection.exec(d3.select(this).attr("d"))[1];
                    let bottomLeft = bottom.split("A")[0];
                    let bottomRight = bottom.split("0,0,0,0,")[1].substring(0, bottom.split("0,0,0,0,")[1].length-1);
                    let midX = (parseFloat(bottomLeft.split(",")[0]) + parseFloat(bottomRight.split(",")[0])) / 2;
                    let midY = (parseFloat(bottomLeft.split(",")[1]) + parseFloat(bottomRight.split(",")[1])) / 2;
                    arcBaseMidpoints[i] = [midX, midY];
                });

            // Add pokemon sprites along each radial
            for (let i=0; i<radials.length; i++) {
                let pokemon = getSortedPokemonByTypeDescAndAttr(data, radials[i].key, sortingAttribute);

                // Get two points on line along central axis of current type arc
                let arcMidpoint = arcBaseMidpoints[i];
                let arcCentroid = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(y(overallMax))
                    .startAngle(xScale(radials[i].key))
                    .endAngle(xScale(radials[i].key) + xScale.bandwidth())
                    .centroid();

                // Set starting point
                let xAnchor = arcMidpoint[0];
                let yAnchor = arcMidpoint[1];

                // Use points to compute a change vector (u)
                let vec = [arcCentroid[0] - arcMidpoint[0], arcCentroid[1] - arcMidpoint[1]];
                let vecLen = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
                let u = [vec[0] / vecLen, vec[1] / vecLen];

                // Determine offsets
                let imgOffset = (bySubType) ? 13 : 39;
                let xOffset = (u[0] * imgOffset);
                let yOffset = (u[1] * imgOffset);
                let spriteShift = (bySubType) ? 5 : 15;  // amount to shift sprite for point centering

                // Add sprites
                svg.append("g")
                    .selectAll("path")
                    .data(pokemon)
                    .enter()
                    .each(function(d, i) {
                        svg.append("svg:image")
                            .attr("xlink:href", "pokemon_sprites/" + d.pokedex_number + ".png")
                            .attr("class", "pokemon_sprite")
                            .attr("width", () => { return (bySubType) ? 10 : 30 })
                            .attr("height", () => { return (bySubType) ? 10 : 30 })
                            .attr("x", () => {
                                xAnchor += xOffset;
                                return ((xAnchor - xOffset) + xOffset) - spriteShift;
                            })
                            .attr("y", () => {
                                yAnchor += yOffset;
                                return ((yAnchor - yOffset) + yOffset) - spriteShift;
                            })
                            .append("svg:title").text(d.name);

                        // Add labels
                        if (drawLabels === true && i === pokemon.length - 1) {
                            // Determine angle between x-axis & arc centroid for label rotation
                            let theta = Math.atan2(arcMidpoint[1], arcMidpoint[0]) * (180/Math.PI); // convert to degrees
                            let labelShift = (bySubType) ? 2.8 : 1.8; // how far to "step" along the radial
                            let x = xAnchor + (labelShift * xOffset);
                            let y = yAnchor + (labelShift * yOffset);
                            if (arcMidpoint[0] < 0) { theta += 180 }  // flip labels on left side of vis

                            svg.append("text")
                                .attr("class", "typeText")
                                .attr("x", x)
                                .attr("y", y)
                                .attr("transform", "rotate(" + theta + "," + x + "," + y + ")")
                                .style("text-anchor", "middle")
                                .style("font-size", () => { return (bySubType) ? "6px" : "20px"})
                                .text(() => { return capitalize((bySubType) ? getTypeCombo(d) : d.type1).replace("/", " / "); });
                        }
                    });

                // On-click for pokemon images

                $(".pokemon_sprite").on("click", function() {
                    let imgPath = this.getAttribute("href");
                    let id = parseInt(imgPath.split("/")[1].split(".")[0]) - 1;
                    featuringPokemon = true;
                    d3.select(".pokeball").remove();
                    d3.selectAll(".featured_pokemon").remove();

                    /*
                    svg.append("g")
                        .append("circle")
                        .attr("class", "featured_pokemon")
                        .style("stroke", "black")
                        .style("fill", "transparent")
                        .attr("r", () => ((bySubType) ? 90 : 100))
                        .attr("cx", 0)
                        .attr("cy", 0);*/

                    svg.append("svg:image")
                        .attr("xlink:href", imgPath)
                        .attr("class", "featured_pokemon")
                        .attr("width", () => ((bySubType) ? 60 : 50))
                        .attr("height", () => ((bySubType) ? 60 : 50))
                        .attr("x", () => ((bySubType) ? -30 : -25))
                        .attr("y", -70);

                    svg.append("text")
                        .attr("class", "featured_pokemon title")
                        .attr("x", 0)
                        .attr("y", -80)
                        .style("fill", "yellow")
                        .style("text-anchor", "middle")
                        .style("font-size", () => ((bySubType) ? "10px" : "12px"))
                        .text(data[id]["name"]);

                    let statLabelY = 5;
                    let statRectY = (bySubType) ? -3 : -6;
                    let attributeLabels = ["Attack", "HP", "Defense", "Sp. Attack", "Sp. Defense", "Speed"];

                    for (let i = 0; i < attributeLabels.length; i++) {
                        let s = attributeLabels[i].replace(" ", "").replace(".", "_").toLowerCase();
                        let value = data[id][s];

                        svg.append("text")
                            .attr("class", "featured_pokemon")
                            .attr("x", () => ((bySubType) ? -60 : -70))
                            .attr("y", statLabelY)
                            .style("text-anchor", "right")
                            .style("font-size", () => ((bySubType) ? "8px" : "10px"))
                            .style("font-family", "calibri")
                            .style("font-weight", "bold")
                            .text(attributeLabels[i]);

                        svg.append("text")
                            .attr("class", "featured_pokemon")
                            .attr("x", -15)
                            .attr("y", statLabelY)
                            .style("text-anchor", "right")
                            .style("font-size", () => ((bySubType) ? "8px" : "10px"))
                            .style("font-family", "calibri")
                            .text(value);

                        svg.append("rect")
                            .attr("class", "featured_pokemon")
                            .attr("x", 5)
                            .attr("y", statRectY)
                            .attr("rx", 2)
                            .attr("ry", 2)
                            .attr("width", getBarScales(i)[0](value))
                            .attr("height", () => ((bySubType) ? 10 : 14))
                            .style("fill", getBarScales(i)[1](value));

                        statLabelY += (bySubType) ? 12 : 16;
                        statRectY += (bySubType) ? 12 : 16;
                    }
                }).on("mouseout", function() {
                    if (featuringPokemon) {
                        d3.selectAll(".featured_pokemon").remove();
                        drawPokeball();
                        featuringPokemon = false;
                    }
                });
            }
        });
    }

    // Init vis
    add_svg();
    show_vis(bySubType, sortingAttribute, svg);

    /***************
     * Interaction *
     ***************/

    // Add title
    d3.select("#pokemon_vis")
        .insert("text", "svg")
        .attr("class", "title")
        .text("Pokémon - Gen 1");

    // Add div to contain dropdowns
    d3.select("#pokemon_vis")
        .insert("div", "svg")
        .attr("id", "dropdowns");

    // Add type selection dropdown
    let typeChange = function() {
        let selection = d3.select(this).property('value');
        bySubType = (selection !== "Primary Type");
        reDrawVis();  // Delete then re-draw vis
    };

    d3.select("#dropdowns")
        .insert("label", "svg")
        .attr("for", "typeDropdown")
        .text("Type Mode:");
    insertBreak();

    let typeDropdown = d3.select("#dropdowns")
        .insert("select", "svg")
        .attr("id", "typeDropdown")
        .on("change", typeChange);
    insertBreak();
    insertBreak();

    typeDropdown.selectAll("option")
        .data(["Primary Type", "Primary Type / Secondary Type"])
        .enter().append("option")
        .attr("value", function (d) { return d; })
        .text(function (d) { return d; });

    // Pre-select typeDropdown selection if url-param provided
    let typeSelection = getUrlParameter("id");
    if (typeSelection !== null) {
        typeSelection = typeSelection.replace(new RegExp("%22", 'g'), "");
        typeSelection = typeSelection.replace(new RegExp("%27", 'g'), "");
        typeSelection = typeSelection.replace(new RegExp("%20", 'g'), " ");
        bySubType = typeSelection !== "Primary Type";
        d3.select('#typeDropdown').property('value', typeSelection);
        reDrawVis();
    }

    // Add sorting attribute dropdown
    let sortByChange = function() {
        sortingAttribute = d3.select(this).property('value');
        d3.select("image").remove();                       // remove all pokemon sprites
        show_vis(bySubType, sortingAttribute, svg, false); // re-draw vis w/o re-drawing the radial labels
    };

    d3.select("#dropdowns")
        .insert("label", "svg")
        .attr("for", "sortDropdown")
        .text("Sort By:");
    insertBreak();

    let sortByDropdown = d3.select("#dropdowns")
        .insert("select", "svg")
        .attr("id", "sortDropdown")
        .on("change", sortByChange);

    let names = ["Pokédex Number", "Name", "Attack", "Defense", "HP", "Speed", "Special Attack", "Special Defense", "Height (m)", "Weight (kg)", "Percentage Male"];

    sortByDropdown.selectAll("option")
        .data(["pokedex_number", "name", "attack", "defense", "hp", "speed", "sp_attack", "sp_defense", "height_m", "weight_kg", "percentage_male"])
        .enter().append("option")
        .attr("value", function (d) { return d; })
        .text(function (d, i) { return names[i]; });

    /********************
     * Helper Functions *
     ********************/

    function insertBreak() {
        d3.select("#dropdowns").insert("br", "svg");
    }

    function getTypeCombo(d) {
        return (d.type2 === "" || d.type1 === d.type2) ? d.type1 : d.type1 + "/" + d.type2;
    }

    function capitalize(s) {
        if (s.indexOf("/") !== -1) {
            let ts = s.split("/");
            return ts[0].charAt(0).toUpperCase() + ts[0].slice(1) + "/" + ts[1].charAt(0).toUpperCase() + ts[1].slice(1);
        } else {
            return s.charAt(0).toUpperCase() + s.slice(1);
        }
    }

    function getSortedPokemonByTypeDescAndAttr(data, typeDesc, attribute) {
        let pokemon = null;

        if (typeDesc.indexOf("/") !== -1) {
            pokemon = data.filter(function(d) { return typeDesc === getTypeCombo(d) || typeDesc === d.type1; });
        } else {
            pokemon = data.filter(function(d) { return typeDesc === d.type1; });
        }

        return pokemon.sort(function(a, b) {
            return a[attribute] - b[attribute];
        });
    }

    function reDrawVis() {
        d3.select("svg").remove();
        add_svg();
        show_vis(bySubType, sortingAttribute, svg);
    }

    function getUrlParameter(name) {
        let value = null;
        $.each(window.location.search.slice(1).split("&"), function (i, kvp) {
            let values = kvp.split("=");
            if (name === values[0]) {
                value = values[1] ? values[1] : values[0];
                return false;
            }
        });
        return value;
    }
    
</script>